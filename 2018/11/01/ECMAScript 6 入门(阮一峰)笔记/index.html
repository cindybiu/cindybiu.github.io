<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>ECMAScript 6 入门(阮一峰)笔记 - cindyBlog</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">ECMAScript 6 入门(阮一峰)笔记</h1><ul class="meta"><li><i class="icon icon-author"></i>cindy Liu</li><li><i class="icon icon-clock"></i>25 Minutes</li><li><i class="icon icon-calendar"></i>November 1, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><p><img src="https://i.imgur.com/fqWHoys.png" alt=""><br>最近在读阮一峰的《ECMAScript 6 入门》，之前接触es6只知道一些常见的特性，原理并不深入，通过这本书收获很多。之前网上看到过一个题目，问到使用const来定义对象会发生什么，能不能改变值？最初看到这个题目的时候，第一反应就是const是用来定常量的，定义了就不能改变，非常的想当然，但是并没有深入了解原理，现在重新阅读了这本书之后，发现以前的理解有许多偏差，因此也收获了很多，以下是一些读书笔记，将陆续更新</p>
<a id="more"></a>
<h4 id="1、babel-polyfill"><a href="#1、babel-polyfill" class="headerlink" title="1、babel-polyfill"></a>1、babel-polyfill</h4><p>Bable默认只转换新的javascript语法，而不转换新的API，比如iterator、gennerator、set、map、proxy、reflect、symbol、promise等全局对象。<br>举例来说，ES6在Array对象上新增了Array.from方法，babel就不会转换这个方法，需要通过bable-polyfill来进行转换</p>
<h4 id="2、ESLint"><a href="#2、ESLint" class="headerlink" title="2、ESLint"></a>2、ESLint</h4><p>用于静态检查代码的语法和风格</p>
<h4 id="3、let"><a href="#3、let" class="headerlink" title="3、let"></a>3、let</h4><ul>
<li>用来声明变量，用法类似于var， 但是声明的变量，旨在let命令的代码块内有效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure>
<ul>
<li>不存在变量提升</li>
</ul>
<p>在var情况下，变量在声明之前使用，虽然值为undefined,但是不会报错，但是由于let不存在变量提升，因此会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo); // 输出undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// let 的情况</span><br><span class="line">console.log(bar); // 报错ReferenceError</span><br><span class="line">let bar = 2;</span><br></pre></td></tr></table></figure>
<ul>
<li>暂时性死区</li>
</ul>
<p>只要块级作用域内存在let命令，他所声明的变量就绑定在这个区域，不受外部影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不允许重复声明</li>
<li><p>块级作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块级作用域与函数声明</p>
<blockquote>
<p>在ES5中，函数只能在顶层作用域中声明，不能再块级作用域中声明，</p>
</blockquote>
</li>
</ul>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li>const声明一个只读的常量，一旦声明，常量的值就不能改变。</li>
<li>const一旦声明，就必须立即初始化，不能六道以后复制，否则会报错。</li>
<li>本质<blockquote>
<p>const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p>
</blockquote>
</li>
</ul>
<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在指向的内存地址，因此等同于常量。</p>
<p>但对于复合类型的数据（主要是对象和数组），指向的只是一个指向实际数据的指针，const只能保证这个指针固定不懂，至于指向的数据结构是不是可变，就不能控制了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</span><br></pre></td></tr></table></figure>
<p>若真的想将对象冻结，应该使用Object.freeze()</p>
<h5 id="声明变量的六种方法"><a href="#声明变量的六种方法" class="headerlink" title="声明变量的六种方法"></a>声明变量的六种方法</h5><p>var function let const import class</p>
<h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5><p>顶层对象，在浏览器环境指的是window对象，在node指的是global对象</p>
<p>ES5中，顶层对象和全局变量是等价的，而在ES6中，let、const、class声明的全局变量，不属于顶层对象的属性。</p>
<h4 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h4><p>从数组和对象中提取值，对变量进行赋值，被称之为解构。只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure>
<p>只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p>
<h4 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h4><p>ES6为字符串添加了遍历器接口，是的字符可以被for ..of 循环遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let codePoint of &apos;foo&apos;)&#123;</span><br><span class="line">    console.log(condePoint)</span><br><span class="line">&#125;</span><br><span class="line">// f</span><br><span class="line">// o</span><br><span class="line">// o</span><br></pre></td></tr></table></figure>
<h5 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h5><p>传统上，只有indexOf方法可以用来判断一个字符串是否包含另一个字符串。es6提供了以下三种新方法</p>
<ul>
<li>includes() ：返回布尔值，表示是否找到了参数字符串</li>
<li>startsWith():返回布尔值，表示参数字符串是否在原字符串的头部</li>
<li>endsWith():返回布尔值，表示参数字符串是否在原字符串的尾部<br>这三种方法都支持第二个参数，表示开始搜索的位置</li>
</ul>
<h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h5><p>repeat()返回一个新字符串，表示将源字符串重复n次,只针对字符串做操作！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) //xxx</span><br></pre></td></tr></table></figure>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name =&apos;cindy&apos;</span><br><span class="line">let a = `my name is $&#123;name&#125;`</span><br><span class="line">console.log(a) //my name is cindy</span><br></pre></td></tr></table></figure>
<p>若使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中</p>
<p>字符串模板中还能调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    return &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`foo $&#123;fn()&#125; bar` //&quot;foo Hello world bar&quot;</span><br></pre></td></tr></table></figure></p>
<p>大括号内可以放任意表达式、函数、变量</p>
<h4 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a><del>正则的扩展</del></h4><h4 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a><del>数值的扩展</del></h4><h4 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h4><h5 id="函数参数允许指定默认值"><a href="#函数参数允许指定默认值" class="headerlink" title="函数参数允许指定默认值"></a>函数参数允许指定默认值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log(x,y = &apos;world&apos;)&#123;</span><br><span class="line">    console.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;) // &quot;Hello world&quot;</span><br><span class="line">log(&apos;Hello&apos;,&apos;cindy&apos;) // &quot;Hello cindy&quot;</span><br><span class="line">log(&apos;Hello&apos;,&apos;&apos;) // &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<h5 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h5><p>返回没有置顶默认值的参数个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function (a)&#123;&#125;).length //1</span><br><span class="line">(function (a=1)&#123;&#125;),length //0</span><br></pre></td></tr></table></figure></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>可以使用一个圆括号代表参数部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt;5</span><br><span class="line">//相当于</span><br><span class="line">var f = function ()&#123;</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sum = (num1,num2)=&gt;num1+num2;</span><br><span class="line">//等同于</span><br><span class="line">var sum = function (num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="箭头函数的使用注意点"><a href="#箭头函数的使用注意点" class="headerlink" title="箭头函数的使用注意点"></a>箭头函数的使用注意点</h5><ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象！</li>
<li>不可以当作构造函数，也就是说，不能使用new，否则会抛出一个错误。</li>
<li>使用rest代替arguments对象</li>
<li>箭头函数不可以作为generator函数</li>
</ul>
<p>==this对象的指向是可变的，但是在箭头函数中，他是固定的==</p>
<p>箭头函数根本没有自己的this,导致内部this就是外层代码块的this,正是因为没有this， 所以不能用作构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于 ES5</span><br><span class="line">function foo() &#123;</span><br><span class="line">  var _this = this;</span><br><span class="line"></span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, _this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line">//转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</span><br></pre></td></tr></table></figure>
<p>请问下面的代码之中有几个this？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        console.log(&apos;id:&apos;, this.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = foo.call(&#123;id: 1&#125;);</span><br><span class="line"></span><br><span class="line">var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1</span><br><span class="line">var t2 = f().call(&#123;id: 3&#125;)(); // id: 1</span><br><span class="line">var t3 = f()().call(&#123;id: 4&#125;); // id: 1</span><br></pre></td></tr></table></figure>
<h5 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h5><p>由于箭头函数并不适用于所有场合，因此“函数绑定”运算符，用来取代call、bind、apply调用</p>
<p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line">// 等同于</span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line">// 等同于</span><br><span class="line">bar.apply(foo, arguments);</span><br><span class="line"></span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line">function hasOwn(obj, key) &#123;</span><br><span class="line">  return obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代替函数的apply方法"><a href="#代替函数的apply方法" class="headerlink" title="代替函数的apply方法"></a>代替函数的apply方法</h5><p>由于扩展运算符可以展开数组，因此不再需要apply方法，下面是利用扩展运算符求一个数组最大元素的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//es5</span><br><span class="line">Math.max.apply(null,[1,23,4,5,3])</span><br><span class="line"></span><br><span class="line">//es6</span><br><span class="line">Math.max(...[1,23,4,5,3])</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line">Math.max(1,23,4,5,3)</span><br></pre></td></tr></table></figure></p>
<h5 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h5><ul>
<li><p>复制数组<br>es5中复制数组的时候只是复制了底层数据结构的指针，更改a2会影响a1，但使用了扩展运算符会避免这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1=[1,2]</span><br><span class="line">const a2=[...a1]</span><br><span class="line">a2[0]=0</span><br><span class="line">a2 //[0,2]</span><br><span class="line">a1 //[1,2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arr1,...arr2,...arr3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h5><p>Array.from 方法用于将两类对象转为真正的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h5><p>Array.of()用于将一组数值，转换为数组</p>
<h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><h5 id="属性的便利"><a href="#属性的便利" class="headerlink" title="属性的便利"></a>属性的便利</h5><ul>
<li>for…in 循环遍历对象自身的和继承的可枚举属性</li>
<li>Object.keys(obj) 返回一个数组，包括对象自身（不含继承）所有枚举属性的键名</li>
<li>Object.getOwnPropertyNames(obj) 返回一个数组，包含对象自身的所有属性的键名</li>
<li>Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li>
<li>Reflect.ownKeys(obj) 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li>
<li></li>
</ul>
<h5 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h5><p>指向当前对象的原型对象</p>
<h4 id="对象新增的方法"><a href="#对象新增的方法" class="headerlink" title="对象新增的方法"></a>对象新增的方法</h4><h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>用来比较两个值是否严格相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.is(&apos;foo&apos;, &apos;foo&apos;)</span><br><span class="line">// true</span><br><span class="line">Object.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Object.assign 实行的是浅拷贝</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>类似于数组，但是成员的值都是唯一的，因此可以用来去重</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure>
<h3 id="后续添加如下笔记"><a href="#后续添加如下笔记" class="headerlink" title="后续添加如下笔记"></a>后续添加如下笔记</h3><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><h4 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h4><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><h4 id="ES6面试"><a href="#ES6面试" class="headerlink" title="ES6面试"></a>ES6面试</h4></div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a><span class="category-list-count">12</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjpaw3frk00047gvx1q7xqeya" data-title="ECMAScript 6 入门(阮一峰)笔记" data-url="http://yoursite.com/2018/11/01/ECMAScript 6 入门(阮一峰)笔记/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/10/15/《图解http 》笔记/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/BoizZ" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/heqibang" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.segmentfault.com/u/bon" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 cindyBlog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>