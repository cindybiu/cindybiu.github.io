<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>ES6、babel学习笔记 - cindyBlog</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">ES6、babel学习笔记</h1><ul class="meta"><li><i class="icon icon-author"></i>cindy Liu</li><li><i class="icon icon-clock"></i>26 Minutes</li><li><i class="icon icon-calendar"></i>May 30, 2018</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><hr>
<blockquote>
<p>ECMAscript6 是javascript语言的下一代标准，因为ES6是在2015年发布的，所以又称ECMAScript2015  </p>
<ul>
<li>ES6 = ES2015</li>
</ul>
</blockquote>
<h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><blockquote>
<p>babel是一个ES6转码器，可以将ES6代码转换成ES5,从而兼容所有浏览器。</p>
</blockquote>
<h4 id="ES6的特性"><a href="#ES6的特性" class="headerlink" title="ES6的特性"></a>ES6的特性</h4><blockquote>
<p>let , const , class , extends , super , arrow functions , template string , destructuring , default , rest arguments</p>
</blockquote>
<h5 id="let"><a href="#let" class="headerlink" title="let"></a>let</h5><p>这两个用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name = &apos;zach&apos;</span><br><span class="line">while(true)&#123;</span><br><span class="line">    var name = &apos;obama&apos;;</span><br><span class="line">    console.log(name); //obama</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">console.log(name); //obama</span><br></pre></td></tr></table></figure>
<p>使用var 两次输出的都是obamam,因为ES5只有全局作用域和函数作用域，没有块级作用域，因此以上的例子内层变量会覆盖外层变量。而let实际上为javascript新增了块级作用域。例如<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;zach&apos;</span><br><span class="line">while(true)&#123;</span><br><span class="line">    let name = &apos;obama&apos;</span><br><span class="line">    console.log(name) //obama</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">console.log(name) //zach</span><br></pre></td></tr></table></figure></p>
<p>另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for(var i = 0 ; i &lt; 10; i++)&#123;</span><br><span class="line">    a[i] = function ()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); //10</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">    a[i] = function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); //6</span><br></pre></td></tr></table></figure></p>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p>const也用来声明变量，但是声明的是常量，一旦声明，常量的值就不能改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI = Math.PI</span><br><span class="line">PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only</span><br></pre></td></tr></table></figure></p>
<h5 id="class-extends-super"><a href="#class-extends-super" class="headerlink" title="class, extends ,super"></a>class, extends ,super</h5><blockquote>
<p>这三个特征涉及了ES5中最令人头疼的几个部分:原型、构造函数、继承….<br>ES6提供了更接近传统语言的揭发，引入了==Class(类==)这个概念，新的class写法让对原型的写法更加清晰、更像面向对象编程的语法，更通俗易懂</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &quot;animal&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        console.log(this.type = &apos; says &apos;+ say)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = new Animal()</span><br><span class="line">animal.says(&apos;hello&apos;) //animals says hello</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        this.type = &apos;cat&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat()</span><br><span class="line">cat.says(&apos;hello&apos;) //cat says hello</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先用==class==定义了一个类， 里面有个构造方法 即<strong>constructor()</strong>,而this关键字则代表实例对象。（简单的说 <strong>constructor()</strong> 内定义的方法和属性是实例对象自己的，而<strong>constructor()</strong>外定义的方法和属性则是所有实例对象可以共享的。）</p>
</li>
<li><p><strong>class</strong>之间可以通过==extends==关键字实现继承，上面定义了一个<strong>Cat</strong>类，该类通过<strong>extends</strong>关键字，继承了<strong>Animal</strong>类的所有属性和方法。</p>
</li>
<li><p>==super== 关键字，它指代父类的实例（即父类的<strong>this</strong>对象）。子类必须在<strong>constructor</strong>方法中调用<strong>super</strong>方法，否则新建实例时会报错。因为子类没有自己的<strong>this</strong>对象，而是继承父类的<strong>this</strong>对象，然后对其进行加工。如果不调用<strong>super</strong>方法，子类旧的得不到<strong>this</strong>对象。</p>
</li>
</ul>
<h5 id="arrow-function"><a href="#arrow-function" class="headerlink" title="arrow function"></a>arrow function</h5><p>ES6中最最常见的一个新特性，用它来写function比原来的写法要简洁清晰很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function(i)&#123;return i+1 ; &#125; //ES5</span><br><span class="line">(i) =&gt; i+1 //ES6</span><br></pre></td></tr></table></figure></p>
<p>如果方程比较复杂，则需要用{}把代码包起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function(x,y)&#123;</span><br><span class="line">    x++;</span><br><span class="line">    y--;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125; //ES5</span><br><span class="line"></span><br><span class="line">(x,y) =&gt; &#123;x++;y--;return x+y&#125; //ES6</span><br></pre></td></tr></table></figure></p>
<p>除此之外，arrow function还有另一个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &apos;animal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(this.type + &apos; says &apos; + say)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> var animal = new Animal()</span><br><span class="line"> animal.says(&apos;hi&apos;)  //undefined says hi</span><br></pre></td></tr></table></figure></p>
<p>运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象.<br>但现在我们有了箭头函数，就不需要这么麻烦了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &apos;animal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            console.log(this.type + &apos; says &apos; + say)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> var animal = new Animal()</span><br><span class="line"> animal.says(&apos;hi&apos;)  //animal says hi</span><br></pre></td></tr></table></figure></p>
<p> 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。</p>
<h5 id="template-string"><a href="#template-string" class="headerlink" title="template string"></a>template string</h5><p>这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#result&quot;).append(</span><br><span class="line">  &quot;There are &lt;b&gt;&quot; + basket.count + &quot;&lt;/b&gt; &quot; +</span><br><span class="line">  &quot;items in your basket, &quot; +</span><br><span class="line">  &quot;&lt;em&gt;&quot; + basket.onSale +</span><br><span class="line">  &quot;&lt;/em&gt; are on sale!&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串<code></code>后，我们可以直接这么来写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#result&quot;).append(&apos;</span><br><span class="line">    there are &lt;b&gt; $&#123;basket.count&#125; &lt;/b&gt; items</span><br><span class="line">    in your basket,&lt;em&gt; $(basket.onSale)&lt;/em&gt;</span><br><span class="line">    are on sale!</span><br><span class="line">&apos;);</span><br></pre></td></tr></table></figure></p>
<h5 id="destructuring"><a href="#destructuring" class="headerlink" title="destructuring"></a>destructuring</h5><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（destructuring）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cat = &apos;ken&apos;</span><br><span class="line">let dog = &apos;lili&apos;</span><br><span class="line">let zoo = &#123;cat : cat ,dog : dog&#125;</span><br><span class="line">console.log(zoo) //object&#123;cat:&apos;ken&apos;, dog:&apos;lili&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>用ES6完全可以像下面这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let cet = &apos;ken&apos;</span><br><span class="line">let dog = &apos;lili&apos;</span><br><span class="line">let zoo = &#123;cat, dog&#125;</span><br><span class="line">console.log(zoo) //object&#123;cat : &apos;ken&apos;, dog:&apos;lili&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>反过来可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let dog = &#123;type: &apos;animal&apos;, many: 2&#125;</span><br><span class="line">let &#123; type, many&#125; = dog</span><br><span class="line">console.log(type, many)   //animal 2</span><br></pre></td></tr></table></figure></p>
<h5 id="default-rest"><a href="#default-rest" class="headerlink" title="default,rest"></a>default,rest</h5><p>==default==很简单，意思是默认值。大家可以看下面的例子，调用<strong>animal()</strong>方法时忘了传参数，传统的做法就是加上这一句 <strong>type = type || ‘cat’</strong> 来指定默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function animal(type)&#123;</span><br><span class="line">    type = type || &apos;cat&apos;</span><br><span class="line">    console.log(type)</span><br><span class="line">&#125;</span><br><span class="line">animal() //cat</span><br></pre></td></tr></table></figure>
<p>ES6:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funciton animal(type = &apos;cat&apos;)&#123;</span><br><span class="line">    console.log(type) </span><br><span class="line">&#125;</span><br><span class="line">animal() //cat</span><br></pre></td></tr></table></figure>
<p>最后一个==rest==语法也很简单，直接看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function animals(...types)&#123;</span><br><span class="line">    console.log(types)</span><br><span class="line">&#125;</span><br><span class="line">animals(&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;) //[&quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;]</span><br></pre></td></tr></table></figure>
<p>而如果不用ES6的话，我们则得使用ES5的arguments。</p>
<hr>
<h5 id="import-export"><a href="#import-export" class="headerlink" title="import export"></a>import export</h5><p>这两个特性对应的就是es6自己的module 功能。<br>==传统的写法==:假如有两个js文件:<strong>index.js</strong> 和 <strong>content.js</strong>。 现在要在<strong>index.js</strong> 中使用<strong>content.js</strong> 返回的结果。该如何实现？<br><br>首先定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//content.js</span><br><span class="line">define(&apos;content.js&apos;,function()&#123;</span><br><span class="line"> return &apos;A car&apos;;   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后 require：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">require([&apos;./content.js&apos;],function(animal)&#123;</span><br><span class="line">    console.log(animal) ; //A cat</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>那==CommonJS==是怎么写的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">var animal = require(&apos;./content.js&apos;)</span><br><span class="line"></span><br><span class="line">//content.js</span><br><span class="line">module.exports = &apos;A cat&apos;</span><br></pre></td></tr></table></figure>
<p>==ES6的写法==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js </span><br><span class="line">import animal from &apos;./content&apos;</span><br><span class="line"></span><br><span class="line">//content.js</span><br><span class="line">export default &apos;A cat&apos;</span><br></pre></td></tr></table></figure>
<p>ES6 module的其他高级用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//content.js</span><br><span class="line">export default &apos;A cat&apos; </span><br><span class="line">export function say()&#123;</span><br><span class="line">    return &apos;Hello!&apos;</span><br><span class="line">&#125;</span><br><span class="line">export const type = &apos;dog&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import &#123; say,type &#125;from &apos;./content&apos;</span><br><span class="line">let says = say()</span><br><span class="line">console.log(&apos;The $&#123;type&#125; says $&#123;says&#125;&apos;) // The dog says Hello!</span><br></pre></td></tr></table></figure>
<p>这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。</p>
<p>如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, &#123; say, type &#125; from &apos;./content&apos;  </span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`)  </span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure></p>
<h4 id="修改变量名"><a href="#修改变量名" class="headerlink" title="修改变量名"></a>修改变量名</h4><p>此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import animal,&#123; say, type as animalType &#125; from &apos;.content&apos;</span><br><span class="line">let says = say()</span><br><span class="line">console.log(&apos;The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;&apos;) </span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure></p>
<h4 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h4><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import animal, * as content from &apos;./content&apos;</span><br><span class="line">let says = content.say()</span><br><span class="line">console.log(&apos;The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;&apos;)</span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure>
<p><strong>通常星号*结合as一起使用比较合适。</strong></p>
<hr>
<h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><h4 id="浅谈Object-assign"><a href="#浅谈Object-assign" class="headerlink" title="浅谈Object.assign"></a>浅谈Object.assign</h4><p> Object.assign主要用来合并多个javesrcipt的对象，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var target  = &#123;a : 1&#125;; //目标对象</span><br><span class="line">var source1 = &#123;b : 2&#125;; //源对象1</span><br><span class="line">var source2 = &#123;c : 3&#125;; //源对象2</span><br><span class="line">var source3 = &#123;c : 4&#125;;//源对象3，和source2中的对象有同名属性c</span><br><span class="line">Object.assign(target,source1,source2,source3);</span><br><span class="line">//结果如下：</span><br><span class="line">//&#123;a:1,b:2,c:4&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a><span class="category-list-count">8</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjoiajtex000840vxao3tjtjs" data-title="ES6、babel学习笔记" data-url="http://yoursite.com/2018/05/30/ES6、babel学习笔记/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/07/05/react-router 学习笔记/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/05/06/vue项目中this指向作用域问题/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/BoizZ" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/heqibang" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.segmentfault.com/u/bon" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 cindyBlog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>