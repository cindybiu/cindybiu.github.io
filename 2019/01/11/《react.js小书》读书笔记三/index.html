<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>《react.js小书》读书笔记三 - cindyBlog</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">《react.js小书》读书笔记三</h1><ul class="meta"><li><i class="icon icon-author"></i>cindy Liu</li><li><i class="icon icon-clock"></i>27 Minutes</li><li><i class="icon icon-calendar"></i>January 11, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><p><img src="https://i.imgur.com/E9DsaVY.jpg" alt=""></p>
<blockquote>
<p>《react.js》小书非常基础，适合入门新手，非常好理解，规定自己三天时间内阅读完并确保最基本的知识都掌握了，将一些平时回忽略的注意点做了小笔记和总结</p>
</blockquote>
<h5 id="《react-js小书》读书笔记一"><a href="#《react-js小书》读书笔记一" class="headerlink" title="《react.js小书》读书笔记一"></a><a href="https://cindybiu.github.io/2019/01/10/%E3%80%8Areact.js%E5%B0%8F%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/" title="《react.js小书》读书笔记一" target="_blank" rel="noopener">《react.js小书》读书笔记一</a></h5><h5 id="《react-js小书》读书笔记二"><a href="#《react-js小书》读书笔记二" class="headerlink" title="《react.js小书》读书笔记二"></a><a href="https://cindybiu.github.io/2019/01/11/%E3%80%8Areact.js%E5%B0%8F%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="《react.js小书》读书笔记二" target="_blank" rel="noopener">《react.js小书》读书笔记二</a></h5><h5 id="在线阅读：http-huziketang-com-books-react"><a href="#在线阅读：http-huziketang-com-books-react" class="headerlink" title="在线阅读：http://huziketang.com/books/react/"></a>在线阅读：<a href="http://huziketang.com/books/react/" target="_blank" rel="noopener">http://huziketang.com/books/react/</a></h5><h5 id="在线OJ试题：http-scriptoj-mangojuice-top-problemsGroups-593a2e29b3838c385539fa4f"><a href="#在线OJ试题：http-scriptoj-mangojuice-top-problemsGroups-593a2e29b3838c385539fa4f" class="headerlink" title="在线OJ试题：http://scriptoj.mangojuice.top/problemsGroups/593a2e29b3838c385539fa4f"></a>在线OJ试题：<a href="http://scriptoj.mangojuice.top/problemsGroups/593a2e29b3838c385539fa4f" target="_blank" rel="noopener">http://scriptoj.mangojuice.top/problemsGroups/593a2e29b3838c385539fa4f</a></h5><a id="more"></a>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>就是一个函数，传给它一个组件，它会返回一个新的组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const NewComponeent = higherOrderComponent(OldComponent)</span><br></pre></td></tr></table></figure></p>
<p><strong>高阶组件是一个函数，而不是组件，他接受一个组件作为参数，返回一个新的组件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export default (WrappedComponent) =&gt; &#123;</span><br><span class="line">    class NewComponent extents Component &#123;</span><br><span class="line">        // 可以做很多自定义逻辑</span><br><span class="line">        render () &#123;</span><br><span class="line">            return &lt;WrappedComponent /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NewComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在给NewComponent 做一些数据启动工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">export default (WrappedComponent, name) =&gt; &#123;</span><br><span class="line">    class NewComponent extents Component &#123;</span><br><span class="line">        constuctor ()&#123;</span><br><span class="line">            super()</span><br><span class="line">            this.state=&#123; data:null &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        componentWillMount () &#123;</span><br><span class="line">            let data = localStorage.getItem(name)</span><br><span class="line">            this.setState(&#123; data&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        render () &#123;</span><br><span class="line">            return &lt;WrappedComponent data=&#123;this.state.data&#125;/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NewComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>高阶组件的作用其实是为了组件之间的代码复用，组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用。高阶组件内部的包装组件和被包装组件之间通过props传递数据。（其实就是设计模式中的装饰者模式）</p>
</blockquote>
<h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>某个组件只要往自己的context里面放了某些状态，这个组件之下的所有子组件都直接访问这个状态而不需要通过中间件的传递。（只有子组件可以访问，父组件不行）</p>
<h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p> redux和react-redux不是同一个东西，redux是一种架构模式，是flux架构的变种，可以同react和vue等库结合，而react-redux就是redux与react.js结合起来的一个库</p>
<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p> store是一个集合，使用createStore来专门生产state 和 dispatch,包含了如下几种方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createStore (state, stateChanger) &#123;</span><br><span class="line">   const listeners = []</span><br><span class="line">   const getState = () =&gt; state</span><br><span class="line">   const subscribe = (listener) =&gt; listeners.push(listener)</span><br><span class="line">   const dispatch = (action) =&gt; &#123;</span><br><span class="line">     stateChanger(state, action)</span><br><span class="line">     listeners.forEach((listener) =&gt; listener())</span><br><span class="line">   &#125;</span><br><span class="line">   return &#123; getState, dispatch, subscribe &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getState 用于获取state数据，其实就是简单的把state参数返回</li>
<li>subscribe 用来监听数据的变化</li>
<li><p>dispatch 用于修改数据，接受一个action，可以根据action来修改state</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123; type: &apos;UPDATE_TITLE_TEXT&apos;, text: &apos;《React.js 小书》&apos; &#125;) // 修改标题文本</span><br><span class="line">store.dispatch(&#123; type: &apos;UPDATE_TITLE_COLOR&apos;, color: &apos;blue&apos; &#125;) // 修改标题颜色</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="纯函数："><a href="#纯函数：" class="headerlink" title="纯函数："></a>纯函数：</h4><h5 id="函数的返回结果只依赖于它的参数"><a href="#函数的返回结果只依赖于它的参数" class="headerlink" title="函数的返回结果只依赖于它的参数"></a>函数的返回结果只依赖于它的参数</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">const foo = (b) =&gt; a+b</span><br><span class="line">foo(2) // 3</span><br><span class="line">//foo 不是一个纯函数，因为返回结果依赖于外部变量a </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const foo2 = (x, b) =&gt; x + b</span><br><span class="line">foo2(1,2) //3</span><br><span class="line">//foo2是一个纯函数，因为只依赖于参数</span><br></pre></td></tr></table></figure>
<h5 id="函数执行过程没有副作用"><a href="#函数执行过程没有副作用" class="headerlink" title="函数执行过程没有副作用"></a>函数执行过程没有副作用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">consst a = 1</span><br><span class="line">const foo = (obj, b) =&gt; &#123;</span><br><span class="line">    return obj.x + b</span><br><span class="line">&#125;</span><br><span class="line">const counter = &#123; x : 1 &#125;</span><br><span class="line">foo(counter,2)</span><br><span class="line">counter.x // 1</span><br><span class="line">// foo 是一个纯函数，计算前后的counter并不会发生任何改变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const a = 1</span><br><span class="line">const foo = (obj, b) =&gt; &#123;</span><br><span class="line">  obj.x = 2</span><br><span class="line">  return obj.x + b</span><br><span class="line">&#125;</span><br><span class="line">const counter = &#123; x: 1 &#125;</span><br><span class="line">foo2(counter, 2) // =&gt; 4</span><br><span class="line">counter.x // =&gt; 2</span><br><span class="line">//foo2不是纯函数，计算前后counter发生了改变。</span><br></pre></td></tr></table></figure>
<h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><p>createStore接受一个叫reducer的函数作为参数，这个函数规定是一个纯函数，他接受两个参数，一个是state，一个是action。如果没有传入state或者state为null，那么他就会返回一个初始化的诗句，如果有传入state的话，那么就会根据action来修改数据，如果不能识别action，就不会产生新的数据，而是把state原封不动返回。</p>
<h4 id="回顾redux"><a href="#回顾redux" class="headerlink" title="回顾redux"></a>回顾redux</h4><ul>
<li>发现问题：如果共享数据状态可以被任意修改的话，那么程序行为将会不可预料</li>
<li>解决问题：提高修改数据的门槛，必须通过dispatch来执行某些允许的修改操作，并且在action里面声明（通过action中的type来判断是否允许修改）</li>
<li>优化方案：抽象出一个createStore,可以产生store，里面包含getState 和 dispatch函数.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createStore( stateChanger) &#123;</span><br><span class="line">    let state = null</span><br><span class="line">    const listeners = []</span><br><span class="line">    const subscribe = (listener) =&gt; listeners.push(listener)</span><br><span class="line">    const getState = () =&gt; state</span><br><span class="line">    const dispatch = (action) =&gt; &#123;</span><br><span class="line">        state = stateChanger(state, action) // 覆盖原对象</span><br><span class="line">        listeners.forEach((listener) =&gt; listener())</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;&#125;) // 初始化 state</span><br><span class="line">    return &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发现问题: 每次修改数据都要手动渲染很麻烦.</li>
<li>解决问题: 加入了订阅者模式. store.subscribe订阅数据修改事件,每次数据更新会自动渲染</li>
<li>优化方案: 引入”共享结构的对象”,在每个渲染函数开头进行简单的判断,避免没有被修改过的数据重新渲染</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (newAppState === oldAppState) return</span><br></pre></td></tr></table></figure>
<ul>
<li>优化方案: 优化了stateChanger为reducer,定义了reducer只能是纯函数,功能是负责初始化或者根据action.type修改state</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义一个reducer</span><br><span class="line">function reducer (state, action) &#123;</span><br><span class="line">    //初始化state 和 switch case 计算返回新state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成store</span><br><span class="line">const store = createStore(reducer)</span><br><span class="line"></span><br><span class="line">//监听数据变化重新渲染页面</span><br><span class="line">store.subscribe(() =&gt; renderApp(store.getState()))</span><br><span class="line"></span><br><span class="line">//后面可以随意dispatch了,页面自动更新</span><br><span class="line">store.dispatch(......)</span><br></pre></td></tr></table></figure>
<p>完整代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">function createStore( stateChanger) &#123;</span><br><span class="line">    let state = null</span><br><span class="line">    const listeners = []</span><br><span class="line">    const subscribe = (listener) =&gt; listeners.push(listener)</span><br><span class="line">    const getState = () =&gt; state</span><br><span class="line">    const dispatch = (action) =&gt; &#123;</span><br><span class="line">        state = stateChanger(state, action) // 覆盖原对象</span><br><span class="line">        listeners.forEach((listener) =&gt; listener())</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;&#125;) // 初始化 state</span><br><span class="line">    return &#123;  getState,  dispatch, subscribe&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderApp(newAppState, oldAppState = &#123;&#125;) &#123;</span><br><span class="line">    if (newAppState === oldAppState) return // 数据没有变化就不渲染了</span><br><span class="line">    console.log(&apos;render app...&apos;)</span><br><span class="line">    renderTitle(newAppState.title, oldAppState.title)</span><br><span class="line">    renderContent(newAppState.content, oldAppState.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderTitle(newTitle, oldTitle = &#123;&#125;) &#123;</span><br><span class="line">    console.log(&apos;render title...&apos;)</span><br><span class="line">    if (newTitle === oldTitle) return // 数据没有变化就不渲染了</span><br><span class="line">    const titleDOM = document.getElementById(&apos;title&apos;)</span><br><span class="line">    titleDOM.innerHTML = newTitle.text</span><br><span class="line">    titleDOM.style.color = newTitle.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderContent(newContent, oldContent = &#123;&#125;) &#123;</span><br><span class="line">    if (newContent === oldContent) return // 数据没有变化就不渲染了</span><br><span class="line">    console.log(&apos;render content...&apos;)</span><br><span class="line">    const contentDOM = document.getElementById(&apos;content&apos;)</span><br><span class="line">    contentDOM.innerHTML = newContent.text</span><br><span class="line">    contentDOM.style.color = newContent.color</span><br><span class="line">&#125;</span><br><span class="line">function stateChanger (state, action) &#123;</span><br><span class="line">    if (!state) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: &apos;React.js 小书&apos;,</span><br><span class="line">          color: &apos;red&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        content: &#123;</span><br><span class="line">          text: &apos;React.js 小书内容&apos;,</span><br><span class="line">          color: &apos;blue&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &apos;UPDATE_TITLE_TEXT&apos;:</span><br><span class="line">        return &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          title: &#123;</span><br><span class="line">            ...state.title,</span><br><span class="line">            text: action.text</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      case &apos;UPDATE_TITLE_COLOR&apos;:</span><br><span class="line">        return &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          title: &#123;</span><br><span class="line">            ...state.title,</span><br><span class="line">            color: action.color</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      default:</span><br><span class="line">        return state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">const store = createStore( stateChanger)</span><br><span class="line"></span><br><span class="line">let oldState = store.getState() // 缓存旧的 state</span><br><span class="line"></span><br><span class="line">store.subscribe(() =&gt; &#123;</span><br><span class="line">    const newState = store.getState() // 数据可能变化，获取新的 state</span><br><span class="line">    renderApp(newState, oldState) // 把新旧的 state 传进去渲染</span><br><span class="line">    oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">renderApp(store.getState()) // 首次渲染页面</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; type: &apos;UPDATE_TITLE_TEXT&apos;,text: &apos;《React.js 小书》&apos;&#125;) // 修改标题文本</span><br><span class="line">store.dispatch(&#123; type: &apos;UPDATE_TITLE_COLOR&apos;,color: &apos;blue&apos;&#125;) // 修改标题颜色</span><br></pre></td></tr></table></figure>
<h4 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h4><ul>
<li>高阶函数帮我们从context取数据,Dumb组件帮助我们提高组件的复用性.</li>
<li>用高阶组件包装Dumb,高阶组件和context打交道,把里面的数据取出来通过Props传给Dumb</li>
<li>这个高阶组件叫connect,接受一个组件作为参数,将从context里面取出的store通过props传给这个组件（如下图）</li>
<li><p>通过mapStateToProps告诉高阶组件我们需要什么数据,获取 整合状态<br><img src="https://i.imgur.com/vGELYKF.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = ( state ) =&gt;&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        themeColor:state.themeColor,</span><br><span class="line">        themeName:state.themeName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以现在connect是接受一个参数mapStateToProps,然后返回一个高阶组件(也就是函数),它会接收一个组件作为参数,然后用Connect把组件包装以后再返回.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (state) =&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        themeColor:state.themeColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Header = connect(mapStateToProps)(Header)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过mapDispatchToProps告诉组件需要如何触发dispatch</li>
</ul>
<h2 id="总结过程"><a href="#总结过程" class="headerlink" title="总结过程"></a>总结过程</h2><ul>
<li>创建一个reducer </li>
<li>用createStore函数创建reducer的store</li>
<li>将store放在父组件的context中,子组件都可以访问</li>
<li>使用connect 将 store 和 context 结合起来</li>
<li>connect接收两个参数(mapStateToProps,mapDispatchToProps),分别用于告诉connect需要什么数据和需要触发什么action</li>
<li>Privider作为所有组件树的根节点,外界可以通过props给它提供store.</li>
</ul>
</div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a><span class="category-list-count">17</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjs5p3x4g000if8vx69fvjrp0" data-title="《react.js小书》读书笔记三" data-url="http://yoursite.com/2019/01/11/《react.js小书》读书笔记三/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/01/22/wepack学习笔记/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/01/11/《react.js小书》读书笔记二/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/cindybiu" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/p/1005052090323133" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 cindyBlog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>