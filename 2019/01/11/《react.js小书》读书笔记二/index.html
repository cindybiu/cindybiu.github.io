<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>《react.js小书》读书笔记二 - cindyBlog</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">《react.js小书》读书笔记二</h1><ul class="meta"><li><i class="icon icon-author"></i>cindy Liu</li><li><i class="icon icon-clock"></i>11 Minutes</li><li><i class="icon icon-calendar"></i>January 11, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><p><img src="https://i.imgur.com/c7iAZ8F.jpg" alt=""></p>
<blockquote>
<p>《react.js》小书非常基础，适合入门新手，非常好理解，规定自己三天时间内阅读完并确保最基本的知识都掌握了，将一些平时回忽略的注意点做了小笔记和总结</p>
</blockquote>
<h5 id="《react-js小书》读书笔记一"><a href="#《react-js小书》读书笔记一" class="headerlink" title="《react.js小书》读书笔记一"></a><a href="https://cindybiu.github.io/2019/01/10/%E3%80%8Areact.js%E5%B0%8F%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/" title="《react.js小书》读书笔记一" target="_blank" rel="noopener">《react.js小书》读书笔记一</a></h5><h5 id="《react-js小书》读书笔记三"><a href="#《react-js小书》读书笔记三" class="headerlink" title="《react.js小书》读书笔记三"></a><a href="https://cindybiu.github.io/2019/01/11/%E3%80%8Areact.js%E5%B0%8F%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89/" title="《react.js小书》读书笔记三" target="_blank" rel="noopener">《react.js小书》读书笔记三</a></h5><h5 id="在线阅读：http-huziketang-com-books-react"><a href="#在线阅读：http-huziketang-com-books-react" class="headerlink" title="在线阅读：http://huziketang.com/books/react/"></a>在线阅读：<a href="http://huziketang.com/books/react/" target="_blank" rel="noopener">http://huziketang.com/books/react/</a></h5><h5 id="在线OJ试题：http-scriptoj-mangojuice-top-problemsGroups-593a2e29b3838c385539fa4f"><a href="#在线OJ试题：http-scriptoj-mangojuice-top-problemsGroups-593a2e29b3838c385539fa4f" class="headerlink" title="在线OJ试题：http://scriptoj.mangojuice.top/problemsGroups/593a2e29b3838c385539fa4f"></a>在线OJ试题：<a href="http://scriptoj.mangojuice.top/problemsGroups/593a2e29b3838c385539fa4f" target="_blank" rel="noopener">http://scriptoj.mangojuice.top/problemsGroups/593a2e29b3838c385539fa4f</a></h5><a id="more"></a>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><h4 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h4><p>当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近的公共父组件中去管理。但是这种无限制的提升也会带来很多麻烦，一旦发生提升，就选哟修改原来保存的组件代码，并且把整个数据路径经过的组件都修改一遍。因此引入了redux来帮助我们管理共享状态。</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>react.js将组件渲染，并且构造DOM元素，然后插入页面的过程成为组件的挂载</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul>
<li>constructor：初始化state</li>
<li>componentWillMount：启动工作，如ajax数据拉去，定时器的启动</li>
<li>componentWillUnmount：数据清理，如定时器的清理。</li>
<li>componentDidMount：用于一些依赖于DOM的操作</li>
<li>shouldComponentUpdate(nextProps,nextState)：通过这个组件控制是否重新渲染，如果返回false则不重新渲染。可用在react性能优化上面</li>
<li>componentWillReceiveProps(nextProps)：组件从父组件接收到新的props之前调用</li>
<li>componentWillUpdate():组件重新渲染之前调用</li>
<li><p>componentDidUpdate:组件重新渲染并把更改变更到真实的DOM以后调用</p>
<p><a href="https://github.com/livoras/blog/issues/13" title="深度剖析：如何实现一个Vitual DOM算法" target="_blank" rel="noopener"> 深度剖析：如何实现一个Vitual DOM算法</a></p>
</li>
</ul>
<p>ref:用来获取已经挂载的元素的DOM节点，但是记住一个原则 <strong>能不用 ref 就不用</strong><br>基本用法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AutoFocusInput extends Component &#123;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    this.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;AutoFocusInput /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>this.props.children 可以用来获取组件标签底下的所有元素，并且保存成数组的形式组件使用时编写代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Card&gt;</span><br><span class="line">	&lt;h2&gt;React.js 小书&lt;/h2&gt;</span><br><span class="line">	&lt;div&gt;开源、免费、专业、简单&lt;/div&gt;</span><br><span class="line">	订阅：&lt;input /&gt;</span><br><span class="line"> &lt;/Card&gt;</span><br></pre></td></tr></table></figure>
<p>这种写法类似html，标签内部的元素可以使用this.props.children来获取，React.js 就是把我们嵌套的 JSX 元素一个个都放到数组当中，然后通过 props.children 传给了 Card。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Card extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&apos;card&apos;&gt;</span><br><span class="line">        &lt;div className=&apos;card-content&apos;&gt;</span><br><span class="line">          &#123;this.props.children&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过打印this.props.children,可以看到<br><img src="https://i.imgur.com/9uLMPsC.png" alt=""></p>
<p>另外，也可以在组件内部把数组中的jsx安置在不同的地方，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Layout extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&apos;two-cols-layout&apos;&gt;</span><br><span class="line">        &lt;div className=&apos;sidebar&apos;&gt;</span><br><span class="line">          &#123;this.props.children[0]&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=&apos;main&apos;&gt;</span><br><span class="line">          &#123;this.props.children[1]&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dangerouslySetHTML-和-style-属性"><a href="#dangerouslySetHTML-和-style-属性" class="headerlink" title="dangerouslySetHTML 和 style 属性"></a>dangerouslySetHTML 和 style 属性</h4><p>react的所有表达式插入的内容都会被自动转义，相当于jq里面的text(…)函数一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Editor extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      content: &apos;&lt;h1&gt;React.js 小书&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&apos;editor-wrapper&apos;&gt;</span><br><span class="line">        &#123;this.state.content&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dangerouslySetHTML ：可以做到设置动态html结构，使用方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">   return (</span><br><span class="line">     &lt;div</span><br><span class="line">       className=&apos;editor-wrapper&apos;</span><br><span class="line">       dangerouslySetInnerHTML=&#123;&#123;__html: this.state.content&#125;&#125; /&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很有意思的一件事，为什么要把简单的事情搞得这么复杂，名字又长，还要传入一个奇怪的对象，那是因为设置 innerHTML 可能会导致跨站脚本攻击（XSS），所以 React.js 团队认为把事情搞复杂可以防止（警示）大家滥用这个属性。这个属性不必要的情况就不要使用。</p>
</blockquote>
<h4 id="一些命名规范和方法的排放顺序"><a href="#一些命名规范和方法的排放顺序" class="headerlink" title="一些命名规范和方法的排放顺序"></a>一些命名规范和方法的排放顺序</h4><p>私有方法都用 _ 开头，如_loadUsername，监听方法都用handle开头，如handleSubmit。<br>另外，组件的内容白那些顺序如下：</p>
<ol>
<li>static 开头的类属性，如 defaultProps、propTypes。</li>
<li>构造函数，constructor。</li>
<li>getter/setter。</li>
<li>组件生命周期。</li>
<li>_ 开头的私有方法。</li>
<li>事件监听方法，handle*。</li>
<li>render<em>开头的方法，有时候 render() 方法里面的内容会分开到不同函数里面进行，这些函数都以 render</em> 开头。</li>
<li>render() 方法。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>style接收的是一个对象，这个对象里面是这个元素的css属性键值对，并且带 - 的元素都要去掉 - ,换成驼峰命名，如font-size换成fontSize</li>
<li>尽量使用propTypes来定义类型，方便排查错误，规范代码</li>
</ul>
</div><div class="article-meta" style="max-width:800px"><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a><span class="category-list-count">15</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjr1j61qw000iwcvx7gh4aqme" data-title="《react.js小书》读书笔记二" data-url="http://yoursite.com/2019/01/11/《react.js小书》读书笔记二/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/01/11/《react.js小书》读书笔记三/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/01/10/《react.js小书》读书笔记一/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/cindybiu" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/p/1005052090323133" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 cindyBlog<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>